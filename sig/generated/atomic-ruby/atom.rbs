# Generated from lib/atomic-ruby/atom.rb with RBS::Inline

module AtomicRuby
  # Provides atomic reference semantics using Compare-And-Swap (CAS) operations.
  #
  # An Atom allows for lock-free, thread-safe updates to a single reference value.
  # The core operation is {#swap}, which atomically updates the value based on
  # the current value, retrying if another thread modifies it concurrently.
  #
  # @example Basic usage
  #   atom = Atom.new(0)
  #   atom.swap { |current_value| current_value + 1 }
  #   puts atom.value #=> 1
  #
  # @example Thread-safe counter
  #   counter = Atom.new(0)
  #   threads = 10.times.map do
  #     Thread.new { 100.times { counter.swap { |current_count| current_count + 1 } } }
  #   end
  #   threads.each(&:join)
  #   puts counter.value #=> 1000
  #
  # @example Non-mutating array operations
  #   atom = Atom.new([])
  #   atom.swap { |current_array| current_array + [1] }
  #   atom.swap { |current_array| current_array + [2] }
  #   puts atom.value #=> [1, 2]
  #
  # @note This class is Ractor-safe in Ruby 4.0+ when compiled with ractor support.
  #   Values that cross ractor boundaries are automatically made shareable.
  class Atom
    # Creates a new atomic reference with the given initial value.
    #
    # @param value [untyped] The initial value to store atomically
    #
    # @example
    #   atom = Atom.new(42)
    #   atom = Atom.new([1, 2, 3])
    #   atom = Atom.new({ key: "value" })
    #
    # @rbs (untyped value) -> void
    def initialize: (untyped value) -> void

    # Returns the current value stored in the atom.
    #
    # This operation is atomic and thread-safe. The returned value reflects
    # the state at the time of the call, but may change immediately after
    # in concurrent environments.
    #
    # @return [untyped] The current atomic value
    #
    # @example
    #   atom = Atom.new("hello")
    #   puts atom.value #=> "hello"
    #
    # @rbs () -> untyped
    def value: () -> untyped

    # Atomically updates the value using a compare-and-swap operation.
    #
    # The block receives the current value and must return the new value.
    # If another thread modifies the atom between reading the current value
    # and attempting to update it, the operation retries with the new current value.
    #
    # @yieldparam current_value [untyped] The current atomic value
    # @yieldreturn [untyped] The new value to store atomically
    # @return [untyped] The new value that was successfully stored
    #
    # @example Increment a counter
    #   atom = Atom.new(0)
    #   new_value = atom.swap { |current_value| current_value + 1 }
    #   puts new_value #=> 1
    #
    # @example Append to array (non-mutating)
    #   atom = Atom.new([1, 2])
    #   atom.swap { |current_array| current_array + [3] }
    #   puts atom.value #=> [1, 2, 3]
    #
    # @example Conditional update
    #   atom = Atom.new(10)
    #   atom.swap { |current_value| current_value > 5 ? current_value * 2 : current_value }
    #   puts atom.value #=> 20
    #
    # @rbs () { (untyped) -> untyped } -> untyped
    def swap: () { (untyped) -> untyped } -> untyped

    private

    # Makes a value shareable when crossing ractor boundaries.
    #
    # This method ensures ractor safety by automatically making values
    # shareable when they need to cross ractor boundaries in Ruby 4.0+.
    #
    # @param value [untyped] The value to potentially make shareable
    # @return [untyped] The original value or shareable version
    #
    # @rbs (untyped value) -> untyped
    def make_shareable_if_needed: (untyped value) -> untyped
  end
end

Atom: untyped
