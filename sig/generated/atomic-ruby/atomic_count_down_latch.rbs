# Generated from lib/atomic-ruby/atomic_count_down_latch.rb with RBS::Inline

module AtomicRuby
  # Provides a countdown synchronization primitive using atomic operations.
  #
  # AtomicCountDownLatch is a synchronization aid that allows one or more threads
  # to wait until a set of operations being performed in other threads completes.
  # The latch is initialized with a count, and threads can wait for the count
  # to reach zero or decrement the count atomically.
  #
  # @example Basic usage
  #   latch = AtomicCountDownLatch.new(3)
  #
  #   # Start 3 worker threads
  #   3.times do |worker_id|
  #     Thread.new do
  #       puts "Worker #{worker_id} starting"
  #       sleep(rand(2))
  #       puts "Worker #{worker_id} finished"
  #       latch.count_down
  #     end
  #   end
  #
  #   latch.wait # Wait for all workers to complete
  #   puts "All workers finished!"
  #
  # @example Waiting for initialization
  #   latch = AtomicCountDownLatch.new(1)
  #
  #   # Start initialization in background
  #   Thread.new do
  #     puts "Initializing..."
  #     sleep(2)
  #     puts "Initialization complete"
  #     latch.count_down
  #   end
  #
  #   puts "Waiting for initialization..."
  #   latch.wait
  #   puts "Ready to proceed!"
  #
  # @note This class is Ractor-safe in Ruby 4.0+ when compiled with ractor support.
  class AtomicCountDownLatch
    class Error < StandardError
    end

    # Error raised when attempting to count down a latch that is already at zero.
    class AlreadyCountedDownError < Error
    end

    # Creates a new countdown latch with the specified count.
    #
    # @param count [Integer] The initial count value (must be positive)
    #
    # @raise [ArgumentError] if count is not a positive integer
    #
    # @example
    #   latch = AtomicCountDownLatch.new(5)  # Wait for 5 events
    #   latch = AtomicCountDownLatch.new(1)  # Simple binary latch
    #
    # @example Invalid usage
    #   AtomicCountDownLatch.new(0)   #=> raises ArgumentError
    #   AtomicCountDownLatch.new(-1)  #=> raises ArgumentError
    #
    # @rbs (Integer count) -> void
    def initialize: (Integer count) -> void

    # Returns the current count value.
    #
    # This operation is atomic and thread-safe. The returned value reflects
    # the state at the time of the call, but may change immediately after
    # in concurrent environments.
    #
    # @return [Integer] The current count (0 or positive)
    #
    # @example
    #   latch = AtomicCountDownLatch.new(3)
    #   puts latch.count #=> 3
    #   latch.count_down
    #   puts latch.count #=> 2
    #
    # @rbs () -> Integer
    def count: () -> Integer

    # Atomically decrements the count by one.
    #
    # If the count reaches zero, any threads waiting on {#wait} will be unblocked.
    # This operation uses compare-and-swap to ensure atomicity and prevent
    # race conditions.
    #
    # @return [Integer] The new count value after decrementing
    #
    # @raise [AlreadyCountedDownError] if the count is already zero
    #
    # @example
    #   latch = AtomicCountDownLatch.new(2)
    #   latch.count_down #=> 1
    #   latch.count_down #=> 0
    #   latch.count_down #=> raises AlreadyCountedDownError
    #
    # @example Thread-safe countdown
    #   latch = AtomicCountDownLatch.new(10)
    #   10.times do
    #     Thread.new { latch.count_down }
    #   end
    #
    # @rbs () -> Integer
    def count_down: () -> Integer

    # Blocks the current thread until the count reaches zero.
    #
    # This method will block the calling thread until other threads have
    # called {#count_down} enough times to reduce the count to zero.
    # The method uses busy-waiting (Thread.pass) to check the count.
    #
    # @return [void]
    #
    # @example Simple wait
    #   latch = AtomicCountDownLatch.new(1)
    #
    #   Thread.new do
    #     sleep(2)
    #     latch.count_down
    #   end
    #
    #   latch.wait # Blocks for ~2 seconds
    #   puts "Latch opened!"
    #
    # @example Waiting for multiple events
    #   latch = AtomicCountDownLatch.new(3)
    #
    #   3.times do |event_id|
    #     Thread.new do
    #       sleep(1 + event_id)
    #       puts "Event #{event_id} completed"
    #       latch.count_down
    #     end
    #   end
    #
    #   latch.wait # Waits for all 3 events
    #   puts "All events completed!"
    #
    # @rbs () -> void
    def wait: () -> void
  end
end

AtomicCountDownLatch: untyped
