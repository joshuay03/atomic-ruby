# Generated from lib/atomic-ruby/atomic_thread_pool.rb with RBS::Inline

module AtomicRuby
  # Provides a fixed-size thread pool using atomic operations for work queuing.
  #
  # AtomicThreadPool maintains a fixed number of worker threads that process
  # work items from an atomic queue. The pool uses compare-and-swap operations
  # for thread-safe work enqueueing and state management.
  #
  # @example Basic usage
  #   pool = AtomicThreadPool.new(size: 4)
  #   pool << proc { puts "Hello from worker thread!" }
  #   pool << proc { puts "Another work item" }
  #   pool.shutdown
  #
  # @example Processing work with results
  #   results = []
  #   pool = AtomicThreadPool.new(size: 2, name: "Calculator")
  #
  #   10.times do |index|
  #     pool << proc { results << index * 2 }
  #   end
  #
  #   pool.shutdown
  #   puts results.sort #=> [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
  #
  # @example Monitoring pool state
  #   pool = AtomicThreadPool.new(size: 3)
  #   puts pool.length       #=> 3
  #   puts pool.queue_length #=> 0
  #
  #   5.times { pool << proc { sleep(1) } }
  #   puts pool.queue_length #=> 2 (3 workers busy, 2 queued)
  #
  # @note This class is NOT Ractor-safe as it contains mutable thread state
  #   that cannot be safely shared across ractors.
  class AtomicThreadPool
    class Error < StandardError
    end

    # Error raised when attempting to enqueue work after shutdown.
    class EnqueuedWorkAfterShutdownError < Error
      # @rbs () -> String
      def message: () -> String
    end

    # Creates a new thread pool with the specified size.
    #
    # @param size [Integer] The number of worker threads to create (must be positive)
    # @param name [String, nil] Optional name for the thread pool (used in thread names)
    #
    # @raise [ArgumentError] if size is not a positive integer
    # @raise [ArgumentError] if name is provided but not a string
    #
    # @example Create a basic pool
    #   pool = AtomicThreadPool.new(size: 4)
    #
    # @example Create a named pool
    #   pool = AtomicThreadPool.new(size: 2, name: "Database Workers")
    #
    # @rbs (size: Integer, ?name: String?) -> void
    def initialize: (size: Integer, ?name: String?) -> void

    # Enqueues work to be executed by the thread pool.
    #
    # The work item must respond to #call (typically a Proc or lambda).
    # Work items are executed in FIFO order by available worker threads.
    # If all workers are busy, the work is queued atomically.
    #
    # @param work [#call] A callable object to be executed by a worker thread
    #
    # @raise [EnqueuedWorkAfterShutdownError] if the pool has been shut down
    #
    # @example Enqueue a simple task
    #   pool << proc { puts "Hello World" }
    #
    # @example Enqueue a lambda with parameters
    #   calculator = ->(a, b) { puts a + b }
    #   pool << proc { calculator.call(2, 3) }
    #
    # @example Enqueue work that captures variables
    #   name = "Alice"
    #   pool << proc { puts "Processing #{name}" }
    #
    # @rbs (Proc work) -> void
    def <<: (Proc work) -> void

    # Returns the number of currently alive worker threads.
    #
    # This count decreases as the pool shuts down and threads terminate.
    # During normal operation, this should equal the size parameter
    # passed to the constructor.
    #
    # @return [Integer] The number of alive worker threads
    #
    # @example
    #   pool = AtomicThreadPool.new(size: 4)
    #   puts pool.length #=> 4
    #   pool.shutdown
    #   puts pool.length #=> 0
    #
    # @rbs () -> Integer
    def length: () -> Integer

    # Alias for {#length}.
    # @rbs () -> Integer
    alias size length

    # Returns the number of work items currently queued for execution.
    #
    # This represents work that has been enqueued but not yet picked up
    # by a worker thread. A high queue length indicates that work is
    # being submitted faster than it can be processed.
    #
    # @return [Integer] The number of queued work items
    #
    # @example
    #   pool = AtomicThreadPool.new(size: 2)
    #   5.times { pool << proc { sleep(1) } }
    #   puts pool.queue_length #=> 3 (2 workers busy, 3 queued)
    #
    # @rbs () -> Integer
    def queue_length: () -> Integer

    # Alias for {#queue_length}.
    # @rbs () -> Integer
    alias queue_size queue_length

    # Gracefully shuts down the thread pool.
    #
    # This method:
    # 1. Marks the pool as shutdown (preventing new work from being enqueued)
    # 2. Waits for all currently queued work to complete
    # 3. Waits for all worker threads to terminate
    #
    # After shutdown, all worker threads will be terminated and the pool
    # cannot be restarted. Attempting to enqueue work after shutdown
    # will raise an exception.
    #
    # @return [void]
    #
    # @raise [EnqueuedWorkAfterShutdownError] if work is enqueued after shutdown
    #
    # @example
    #   pool = AtomicThreadPool.new(size: 4)
    #   10.times { |index| pool << proc { puts index } }
    #   pool.shutdown # waits for all work to complete
    #   puts pool.length #=> 0
    #
    # @rbs () -> void
    def shutdown: () -> void

    private

    # Starts the worker threads for the thread pool.
    #
    # This method is called automatically during initialization.
    # It creates the specified number of worker threads and waits
    # for all threads to be fully started before returning.
    #
    # @return [void]
    # @rbs () -> void
    def start: () -> void
  end
end

AtomicThreadPool: untyped
